### 11、No.35 搜索插入位置

就是二分查找 ...没啥好说的。



### 12、No.38 外观数列

给定一个正整数 `n` ，输出外观数列的第 `n` 项。

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

你可以将其视作是由递归公式定义的数字字符串序列：

- `countAndSay(1) = "1"`
- `countAndSay(n)` 是对 `countAndSay(n-1)` 的描述，然后转换成另一个数字字符串。

前五项如下：

```
1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"
```

要 **描述** 一个数字字符串，首先要将字符串分割为 **最小** 数量的组，每个组都由连续的最多 **相同字符** 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。

【解析】

**法一、采用双指针 + 递归**。由于每次结果来源于上一次，明显可以采用递归。

双指针指的是：（类似 No.26 删除重复元素），将 left 指向每次不等的第一个数， pos 按顺序遍历每一个，值得注意的是：每次遇到新的数时，需要将 left 指向该新数。且上一个数重复次数，即为当前left  和 之前 left 的距离。

```java
        for (int left = 0; left < sc.length; left++) {
            if(sc[pos] != sc[left]) {
                str +=  String.valueOf(left - pos) +  String.valueOf(sc[pos]);
                pos = left;// 现在指向下一个不等的数
            }// 相等 则向前
        } 
```

且由于最后一组相等的数据还没有加起来，所以需要单独加起来。

**法二、迭代版本**

首先定义

- 变量 pre 记录前一项，初始化为空字符串；
- 定义变量 cur 记录当前项，初始化为 '1'（第一项为 1）；

定义双指针 start， end 均指向序列项的头部，这里用于统计元素出现的次数；
由于给定的  n ≥ 1 ，这里由第 2 项开始逐项对前一项进行描述（注意，要将 cur 赋值给 pre，并初始化 cur 为空字符串，重新拼接得到当前项）：

- 从左往右遍历 pre，当元素相同时，移动 end 指针，直至元素不相同时，那么此时 end-start 就是相同元素的个数，而 start 指针指向的元素就是重复的元素，进行拼接，cur += str(end-start)+pre[start]。
- 此时要让 start 指向 end 所在的位置，开始记录下个元素出现的次数；
- 重复上面的步骤，直至 end 指针到达序列项尾部，便可得到当前项。

逐项对前面一项描述开始时，都应该重置 start、end 指针指向序列项头部，同时应将 cur 赋值给 pre，初始化 cur，也就是前面注意部分所说的内容（可结合代码理解）。然后，再次重复第三个步骤。



代码实现如下

递归版本

```java
    public String countAndSay(int n) {
        if(n == 1) {
            return "1";
        }

        String str = countAndSay(n-1);
        char[] sc = str.toCharArray();// 将上一个函数得到的字符串， 来转换为字符数组

        str = "";// 置为 空
        
        // 采用双指针， 当不等时， 便进行加入。
        int pos = 0;
        for (int left = 0; left < sc.length; left++) {
            if(sc[pos] != sc[left]) {
                str +=  String.valueOf(left - pos) +  String.valueOf(sc[pos]);
                pos = left;// 现在指向下一个不等的数
            }// 相等 则向前
        } 
        // 再将最后一个加起来
        str += String.valueOf(sc.length - pos) + String.valueOf(sc[sc.length-1]);
        
        return str;
    }
```

迭代版本

```java
    // 迭代版本
    public String countAndSay(int n) {
        StringBuffer cur = new StringBuffer("1");// cur 作为当前得到的 str
        StringBuffer pre = new StringBuffer("1");// pre 作为上一个得到的 str
    
        for (int i = 1; i < n; i++) {// 第 0 个为 "1", 所以从第 1 个开始
            pre = cur;// 先将 pre 赋为 上一个的 cur
            cur = new StringBuffer();

            int start = 0, end = 0;
            while(end < pre.length()) {// 遍历每一个
                while(end < pre.length() && pre.charAt(start) == pre.charAt(end)) {
                    end++;
                }
                cur = cur.append(String.valueOf(end-start)).append(pre.charAt(start));
                start = end;// 指示新数据
            }
        }
        return cur.toString();
    }
```

对比两段代码的循环 如下：

```java
 /************     1    *************/
	int pos = 0;
 	for (int left = 0; left < sc.length; left++) {
            if(sc[pos] != sc[left]) {
                str +=  String.valueOf(left - pos) +  String.valueOf(sc[pos]);
                pos = left;// 现在指向下一个不等的数
            }// 相等 则向前
        } 
        // 再将最后一个加起来
	str += String.valueOf(sc.length - pos) + String.valueOf(sc[sc.length-1]);
  /************     2    *************/
	int start = 0, end = 0;
	while(end < pre.length()) {// 遍历每一个
		while(end < pre.length() && pre.charAt(start) == pre.charAt(end)) {
			end++;
        }
		cur = cur.append(Integer.toString(end-start)).append(pre.charAt(start));
		start = end;// 指示新数据
		}
	}
```

第一个需要加上最后一个， 第二个不需要。

这是由于 法一 采用不等的时候才相加，而 法二是浏览完便相加。若为 1 2 3 4 4 ，那么 最后的 4 4 法一并不会加起来，而法二无论值是多少都会加。





### 13、No.53 最大子序列和

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例:**

```
输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

【分析】

**法一：**

主要参考此 [博客](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485355&idx=1&sn=17a59704a657b4880dffb54c40ad730e&chksm=9bd7f9a3aca070b53c3f74c9d0a1074ae1e615699fd3b977b8134d486106e62fb28cdf59cb52&scene=178&cur_album_id=1318881141113536512#rd) 。晕 真的惭愧，之前看了九章 DP 算法课，竟然遇到了还是没想法...果然还是当时刷题没跟上啊...哎，加油吧。

之前的思路一般是 dp 方程为：

**`nums[0..i]`中的「最大的子数组和」为`dp[i]`**。如果这样定义的话，整个`nums`数组的「最大子数组和」就是`dp[n-1]`。

那么如何找状态转移方程呢？按照数学归纳法，假设我们知道了`dp[i-1]`，如何推导出`dp[i]`呢？

**实际上是不行的，因为子数组一定是连续的，按照我们当前`dp`数组定义，并不能保证`nums[0..i]`中的最大子数组与`nums[i+1]`是相邻的**，也就没办法从`dp[i]`推导出`dp[i+1]`。

所以并不能得到 dp 的转移方程。

换个思路，**以`nums[i]`为结尾的「最大子数组和」为`dp[i]`**。

那么此时，`dp[i]`有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。二者选 Max。

```
// 要么自成一派，要么和前面的子数组合并
dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
```

因此最终代码实现为

```java
    public int maxSubArray(int[] nums) {
        if(nums == null || nums.length < 1) {
            return 0;
        }
        // dp[i] 表示 nums[i] 结尾 的最大子数组
        int[] dp = new int[nums.length];

        // 第一个自然为自身
        dp[0] = nums[0];
        for (int i = 1; i < dp.length; i++) {
            // 要么自成一派， 要么加上前面最大的子数组
            dp[i] = Math.max(nums[i], dp[i-1] + nums[i]);
        }

        // 遍历所有 dp
        int res = Integer.MIN_VALUE; 
        for (int i = 0; i < dp.length; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }
```

**法二：**

思路差不多，对每一个值进行遍历，采用一个 sum 来记录当前值 nums[i] 之前的增益。

- sum > 0 ，那么就会是对 当前值的增益，加上
- sum < 0 ，那么 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字

res 通过 Max 来保存每次增益后的最大值。

```java
    public int maxSubArray(int[] nums) {
        if(nums == null || nums.length < 1) {
            return 0;
        }

        int res = nums[0];// 比较得到最终值
        int sum = 0;//记录和
        for (int i = 0; i < nums.length; i++) {
            if(sum > 0) {
                sum += nums[i];
            } else {
                sum = nums[i];
            }
            res = Math.max(res, sum);
        }
        return res;
    }
```



### 14、No.58 最后一个单词长度

给定一个仅包含大小写字母和空格 ' ' 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。

如果不存在最后一个单词，请返回 0 。

说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。

----------

没啥好说的， 注意边界情况："a   " 最后可能有空格，即可。



### 15、No.66 加一

给定一个由**整数**组成的**非空**数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

```
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
```

没啥好说的，，进行优化如下：

且不用全部循环，直接判断该位是否进位，进位就继续，没进位就跳出返回。

对待全进位：直接长度加一，第一个数初始化为1，后面的不管，默认为0。

```
    public int[] plusOne(int[] digits) {
        if(digits == null || digits.length == 0) {
            return null;
        }

        // 直接判断有没有进位， 没有进位就跳出， 不用再循环
        for (int i = digits.length-1; i > -1; i--) {
            digits[i]++; 
            digits[i] %= 10;
            if(digits[i] != 0) {
                return digits;
            }
        }
        // 至此还没跳出， 说明是全进位 999 -> 1000
        digits = new int[digits.length + 1];
        digits[0] = 1;
        return digits;
    }
```





-----------------------------

## Stack

### No.150 逆波兰表达式

